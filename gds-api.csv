defaultBuiltInRoles,description,mode,name,signature
"[reader,editor,publisher,architect,admin]",The All Pairs Shortest Path (APSP) calculates the shortest (weighted) path between all pairs of nodes.,READ,gds.alpha.allShortestPaths.stream,"gds.alpha.allShortestPaths.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, distance :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","ArticleRank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.",READ,gds.alpha.articleRank.stream,"gds.alpha.articleRank.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
"[editor,publisher,architect,admin]","ArticleRank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.",WRITE,gds.alpha.articleRank.write,"gds.alpha.articleRank.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, writeProperty :: STRING?, centralityDistribution :: MAP?)"
"[reader,editor,publisher,architect,admin]","BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",READ,gds.alpha.bfs.stream,"gds.alpha.bfs.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.,READ,gds.alpha.closeness.harmonic.stream,"gds.alpha.closeness.harmonic.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
"[editor,publisher,architect,admin]",Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.,WRITE,gds.alpha.closeness.harmonic.write,"gds.alpha.closeness.harmonic.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, writeProperty :: STRING?, centralityDistribution :: MAP?)"
"[reader,editor,publisher,architect,admin]",Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.,READ,gds.alpha.closeness.stream,"gds.alpha.closeness.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)"
"[editor,publisher,architect,admin]",Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.,WRITE,gds.alpha.closeness.write,"gds.alpha.closeness.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, writeProperty :: STRING?, centralityDistribution :: MAP?)"
"[reader,editor,publisher,architect,admin]","",READ,gds.alpha.collapsePath.mutate,"gds.alpha.collapsePath.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, relationshipsWritten :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]","BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",READ,gds.alpha.dfs.stream,"gds.alpha.dfs.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Eigenvector Centrality measures the transitive influence or connectivity of nodes.,READ,gds.alpha.eigenvector.stream,"gds.alpha.eigenvector.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
"[editor,publisher,architect,admin]",Eigenvector Centrality measures the transitive influence or connectivity of nodes.,WRITE,gds.alpha.eigenvector.write,"gds.alpha.eigenvector.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, iterations :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, dampingFactor :: FLOAT?, writeProperty :: STRING?, centralityDistribution :: MAP?)"
"[reader,editor,publisher,architect,admin]",Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes,READ,gds.alpha.hits.mutate,"gds.alpha.hits.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.hits.mutate.estimate,"gds.alpha.hits.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes,READ,gds.alpha.hits.stats,"gds.alpha.hits.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.hits.stats.estimate,"gds.alpha.hits.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes,READ,gds.alpha.hits.stream,"gds.alpha.hits.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, values :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.hits.stream.estimate,"gds.alpha.hits.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes,WRITE,gds.alpha.hits.write,"gds.alpha.hits.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.hits.write.estimate,"gds.alpha.hits.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Approximate Nearest Neighbors algorithm constructs a k-Nearest Neighbors graph for a set of objects based on a provided similarity function.,READ,gds.alpha.ml.ann.stream,"gds.alpha.ml.ann.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
"[editor,publisher,architect,admin]",The Approximate Nearest Neighbors algorithm constructs a k-Nearest Neighbors graph for a set of objects based on a provided similarity function.,WRITE,gds.alpha.ml.ann.write,"gds.alpha.ml.ann.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?, iterations :: INTEGER?, scanRate :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Predicts relationships for all node pairs based on a previously trained link prediction model,READ,gds.alpha.ml.linkPrediction.predict.mutate,"gds.alpha.ml.linkPrediction.predict.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Trains a link prediction model,READ,gds.alpha.ml.linkPrediction.train,"gds.alpha.ml.linkPrediction.train(graphName :: ANY?, configuration = {} :: MAP?) :: (trainMillis :: INTEGER?, modelInfo :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Predicts classes for all nodes based on a previously trained model,READ,gds.alpha.ml.nodeClassification.predict.mutate,"gds.alpha.ml.nodeClassification.predict.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Trains a node classification model,READ,gds.alpha.ml.nodeClassification.train,"gds.alpha.ml.nodeClassification.train(graphName :: ANY?, configuration = {} :: MAP?) :: (trainMillis :: INTEGER?, modelInfo :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Splits a graph into holdout and remaining relationship types and adds them to the in-memory graph.,READ,gds.alpha.ml.splitRelationships.mutate,"gds.alpha.ml.splitRelationships.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, relationshipsWritten :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Deletes a stored model from disk.,READ,gds.alpha.model.delete,"gds.alpha.model.delete(modelName :: STRING?) :: (modelName :: STRING?, deleteMillis :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Load a stored model into main memory.,READ,gds.alpha.model.load,"gds.alpha.model.load(modelName :: STRING?) :: (modelName :: STRING?, loadMillis :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Make a trained model accessible by all users,READ,gds.alpha.model.publish,"gds.alpha.model.publish(modelName :: STRING?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)"
"[reader,editor,publisher,architect,admin]",Store the selected model to disk.,READ,gds.alpha.model.store,"gds.alpha.model.store(modelName :: STRING?) :: (modelName :: STRING?, storeMillis :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",The Node2Vec algorithm computes embeddings for nodes based on random walks.,READ,gds.alpha.node2vec.stream,"gds.alpha.node2vec.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)"
"[editor,publisher,architect,admin]",The Node2Vec algorithm computes embeddings for nodes based on random walks.,WRITE,gds.alpha.node2vec.write,"gds.alpha.node2vec.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Random Walk is an algorithm that provides random paths in a graph. It’s similar to how a drunk person traverses a city.,READ,gds.alpha.randomWalk.stream,"gds.alpha.randomWalk.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (startNodeId :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Normalize node properties,DEFAULT,gds.alpha.scaleProperties.mutate,"gds.alpha.scaleProperties.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]","The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.",READ,gds.alpha.scc.stream,"gds.alpha.scc.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, componentId :: INTEGER?)"
"[editor,publisher,architect,admin]","The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.",WRITE,gds.alpha.scc.write,"gds.alpha.scc.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, writeProperty :: STRING?)"
"[reader,editor,publisher,architect,admin]",Delta-Stepping is a non-negative single source shortest paths (NSSSP) algorithm.,READ,gds.alpha.shortestPath.deltaStepping.stream,"gds.alpha.shortestPath.deltaStepping.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, distance :: FLOAT?)"
"[editor,publisher,architect,admin]",Delta-Stepping is a non-negative single source shortest paths (NSSSP) algorithm.,WRITE,gds.alpha.shortestPath.deltaStepping.write,"gds.alpha.shortestPath.deltaStepping.write(graphName :: ANY?, configuration = {} :: MAP?) :: (loadDuration :: INTEGER?, evalDuration :: INTEGER?, writeDuration :: INTEGER?, nodeCount :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Cosine-similarity is an algorithm for finding similar nodes based on the cosine similarity metric.,READ,gds.alpha.similarity.cosine.stats,"gds.alpha.similarity.cosine.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Cosine-similarity is an algorithm for finding similar nodes based on the cosine similarity metric.,READ,gds.alpha.similarity.cosine.stream,"gds.alpha.similarity.cosine.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
"[editor,publisher,architect,admin]",Cosine-similarity is an algorithm for finding similar nodes based on the cosine similarity metric.,WRITE,gds.alpha.similarity.cosine.write,"gds.alpha.similarity.cosine.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Euclidean-similarity is an algorithm for finding similar nodes based on the euclidean distance.,READ,gds.alpha.similarity.euclidean.stats,"gds.alpha.similarity.euclidean.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Euclidean-similarity is an algorithm for finding similar nodes based on the euclidean distance.,READ,gds.alpha.similarity.euclidean.stream,"gds.alpha.similarity.euclidean.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
"[editor,publisher,architect,admin]",Euclidean-similarity is an algorithm for finding similar nodes based on the euclidean distance.,WRITE,gds.alpha.similarity.euclidean.write,"gds.alpha.similarity.euclidean.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Overlap-similarity is an algorithm for finding similar nodes based on the overlap coefficient.,READ,gds.alpha.similarity.overlap.stats,"gds.alpha.similarity.overlap.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Overlap-similarity is an algorithm for finding similar nodes based on the overlap coefficient.,READ,gds.alpha.similarity.overlap.stream,"gds.alpha.similarity.overlap.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
"[editor,publisher,architect,admin]",Overlap-similarity is an algorithm for finding similar nodes based on the overlap coefficient.,WRITE,gds.alpha.similarity.overlap.write,"gds.alpha.similarity.overlap.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[editor,publisher,architect,admin]",Pearson-similarity is an algorithm for finding similar nodes based on the pearson correlation coefficient.,WRITE,gds.alpha.similarity.pearson.stats,"gds.alpha.similarity.pearson.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Pearson-similarity is an algorithm for finding similar nodes based on the pearson correlation coefficient.,READ,gds.alpha.similarity.pearson.stream,"gds.alpha.similarity.pearson.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (item1 :: INTEGER?, item2 :: INTEGER?, count1 :: INTEGER?, count2 :: INTEGER?, intersection :: INTEGER?, similarity :: FLOAT?, bidirectional :: BOOLEAN?, reversed :: BOOLEAN?)"
"[editor,publisher,architect,admin]",Pearson-similarity is an algorithm for finding similar nodes based on the pearson correlation coefficient.,WRITE,gds.alpha.similarity.pearson.write,"gds.alpha.similarity.pearson.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, sourceNodes :: INTEGER?, targetNodes :: INTEGER?, similarityPairs :: INTEGER?, computations :: INTEGER?, writeRelationshipType :: STRING?, writeProperty :: STRING?, min :: FLOAT?, max :: FLOAT?, mean :: FLOAT?, stdDev :: FLOAT?, p25 :: FLOAT?, p50 :: FLOAT?, p75 :: FLOAT?, p90 :: FLOAT?, p95 :: FLOAT?, p99 :: FLOAT?, p999 :: FLOAT?, p100 :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.,READ,gds.alpha.sllpa.mutate,"gds.alpha.sllpa.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.sllpa.mutate.estimate,"gds.alpha.sllpa.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.,READ,gds.alpha.sllpa.stats,"gds.alpha.sllpa.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.sllpa.stats.estimate,"gds.alpha.sllpa.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.,READ,gds.alpha.sllpa.stream,"gds.alpha.sllpa.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, values :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.sllpa.stream.estimate,"gds.alpha.sllpa.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.,WRITE,gds.alpha.sllpa.write,"gds.alpha.sllpa.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.alpha.sllpa.write.estimate,"gds.alpha.sllpa.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]","The maximum weight spanning tree (MST) starts from a given node, and finds all its reachable nodes and the set of relationships that connect the nodes together with the maximum possible weight.",WRITE,gds.alpha.spanningTree.kmax.write,"gds.alpha.spanningTree.kmax.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
"[editor,publisher,architect,admin]","The minimum weight spanning tree (MST) starts from a given node, and finds all its reachable nodes and the set of relationships that connect the nodes together with the minimum possible weight.",WRITE,gds.alpha.spanningTree.kmin.write,"gds.alpha.spanningTree.kmin.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
"[editor,publisher,architect,admin]","Maximum weight spanning tree visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is maximized.",WRITE,gds.alpha.spanningTree.maximum.write,"gds.alpha.spanningTree.maximum.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
"[editor,publisher,architect,admin]","Minimum weight spanning tree visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is minimized.",WRITE,gds.alpha.spanningTree.minimum.write,"gds.alpha.spanningTree.minimum.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
"[editor,publisher,architect,admin]","Minimum weight spanning tree visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is minimized.",WRITE,gds.alpha.spanningTree.write,"gds.alpha.spanningTree.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Triangles streams the nodeIds of each triangle in the graph.,READ,gds.alpha.triangles,"gds.alpha.triangles(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeA :: INTEGER?, nodeB :: INTEGER?, nodeC :: INTEGER?)"
"[editor,publisher,architect,admin]",The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.,WRITE,gds.beta.allShortestPaths.dijkstra.mutate,"gds.beta.allShortestPaths.dijkstra.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.allShortestPaths.dijkstra.mutate.estimate,"gds.beta.allShortestPaths.dijkstra.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.,READ,gds.beta.allShortestPaths.dijkstra.stream,"gds.beta.allShortestPaths.dijkstra.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.allShortestPaths.dijkstra.stream.estimate,"gds.beta.allShortestPaths.dijkstra.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.,WRITE,gds.beta.allShortestPaths.dijkstra.write,"gds.beta.allShortestPaths.dijkstra.write(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.allShortestPaths.dijkstra.write.estimate,"gds.beta.allShortestPaths.dijkstra.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.mutate,"gds.beta.fastRPExtended.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.mutate.estimate,"gds.beta.fastRPExtended.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.stats,"gds.beta.fastRPExtended.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.stats.estimate,"gds.beta.fastRPExtended.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.stream,"gds.beta.fastRPExtended.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF NUMBER?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.stream.estimate,"gds.beta.fastRPExtended.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,WRITE,gds.beta.fastRPExtended.write,"gds.beta.fastRPExtended.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",The FastRPExtended algorithm produces node embeddings via random projection of nodes and their properties,READ,gds.beta.fastRPExtended.write.estimate,"gds.beta.fastRPExtended.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","",READ,gds.beta.graph.generate,"gds.beta.graph.generate(graphName :: STRING?, nodeCount :: INTEGER?, averageDegree :: INTEGER?, configuration = {} :: MAP?) :: (name :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, generateMillis :: INTEGER?, relationshipSeed :: INTEGER?, averageDegree :: FLOAT?, relationshipDistribution :: ANY?, relationshipProperty :: ANY?)"
"[reader,editor,publisher,architect,admin]",The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.,READ,gds.beta.graphSage.mutate,"gds.beta.graphSage.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.,READ,gds.beta.graphSage.mutate.estimate,"gds.beta.graphSage.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.,READ,gds.beta.graphSage.stream,"gds.beta.graphSage.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.graphSage.stream.estimate,"gds.beta.graphSage.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.,READ,gds.beta.graphSage.train,"gds.beta.graphSage.train(graphName :: ANY?, configuration = {} :: MAP?) :: (graphName :: STRING?, graphCreateConfig :: MAP?, modelInfo :: MAP?, configuration :: MAP?, trainMillis :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.graphSage.train.estimate,"gds.beta.graphSage.train.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.,WRITE,gds.beta.graphSage.write,"gds.beta.graphSage.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.graphSage.write.estimate,"gds.beta.graphSage.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The K-1 Coloring algorithm assigns a color to every node in the graph.,READ,gds.beta.k1coloring.mutate,"gds.beta.k1coloring.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.k1coloring.mutate.estimate,"gds.beta.k1coloring.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The K-1 Coloring algorithm assigns a color to every node in the graph.,READ,gds.beta.k1coloring.stats,"gds.beta.k1coloring.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.k1coloring.stats.estimate,"gds.beta.k1coloring.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The K-1 Coloring algorithm assigns a color to every node in the graph.,READ,gds.beta.k1coloring.stream,"gds.beta.k1coloring.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, color :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.k1coloring.stream.estimate,"gds.beta.k1coloring.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The K-1 Coloring algorithm assigns a color to every node in the graph.,WRITE,gds.beta.k1coloring.write,"gds.beta.k1coloring.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.k1coloring.write.estimate,"gds.beta.k1coloring.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties,READ,gds.beta.knn.mutate,"gds.beta.knn.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.knn.mutate.estimate,"gds.beta.knn.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.beta.knn.stats,"gds.beta.knn.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, similarityPairs :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.knn.stats.estimate,"gds.beta.knn.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties,READ,gds.beta.knn.stream,"gds.beta.knn.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.knn.stream.estimate,"gds.beta.knn.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties,WRITE,gds.beta.knn.write,"gds.beta.knn.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.knn.write.estimate,"gds.beta.knn.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","",DEFAULT,gds.beta.listProgress,"gds.beta.listProgress() :: (id :: STRING?, taskName :: STRING?, message :: STRING?)"
"[reader,editor,publisher,architect,admin]",Drops a loaded model and frees up the resources it occupies.,READ,gds.beta.model.drop,"gds.beta.model.drop(modelName :: STRING?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)"
"[reader,editor,publisher,architect,admin]",Checks if a given model exists in the model catalog.,READ,gds.beta.model.exists,"gds.beta.model.exists(modelName :: STRING?) :: (modelName :: STRING?, modelType :: STRING?, exists :: BOOLEAN?)"
"[reader,editor,publisher,architect,admin]",Lists all models contained in the model catalog.,READ,gds.beta.model.list,"gds.beta.model.list(modelName = __NO_VALUE :: STRING?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)"
"[reader,editor,publisher,architect,admin]",The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.,READ,gds.beta.modularityOptimization.mutate,"gds.beta.modularityOptimization.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, didConverge :: BOOLEAN?, ranIterations :: INTEGER?, modularity :: FLOAT?, communityCount :: INTEGER?, communityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.modularityOptimization.mutate.estimate,"gds.beta.modularityOptimization.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.,READ,gds.beta.modularityOptimization.stream,"gds.beta.modularityOptimization.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.modularityOptimization.stream.estimate,"gds.beta.modularityOptimization.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.,WRITE,gds.beta.modularityOptimization.write,"gds.beta.modularityOptimization.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, didConverge :: BOOLEAN?, ranIterations :: INTEGER?, modularity :: FLOAT?, communityCount :: INTEGER?, communityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.modularityOptimization.write.estimate,"gds.beta.modularityOptimization.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.",READ,gds.beta.shortestPath.astar.mutate,"gds.beta.shortestPath.astar.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.astar.mutate.estimate,"gds.beta.shortestPath.astar.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.",READ,gds.beta.shortestPath.astar.stream,"gds.beta.shortestPath.astar.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.astar.stream.estimate,"gds.beta.shortestPath.astar.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]","The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.",WRITE,gds.beta.shortestPath.astar.write,"gds.beta.shortestPath.astar.write(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.astar.write.estimate,"gds.beta.shortestPath.astar.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.,READ,gds.beta.shortestPath.dijkstra.mutate,"gds.beta.shortestPath.dijkstra.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.dijkstra.mutate.estimate,"gds.beta.shortestPath.dijkstra.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.,READ,gds.beta.shortestPath.dijkstra.stream,"gds.beta.shortestPath.dijkstra.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.dijkstra.stream.estimate,"gds.beta.shortestPath.dijkstra.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.,WRITE,gds.beta.shortestPath.dijkstra.write,"gds.beta.shortestPath.dijkstra.write(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.dijkstra.write.estimate,"gds.beta.shortestPath.dijkstra.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.,READ,gds.beta.shortestPath.yens.mutate,"gds.beta.shortestPath.yens.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.yens.mutate.estimate,"gds.beta.shortestPath.yens.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.,READ,gds.beta.shortestPath.yens.stream,"gds.beta.shortestPath.yens.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.yens.stream.estimate,"gds.beta.shortestPath.yens.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.,WRITE,gds.beta.shortestPath.yens.write,"gds.beta.shortestPath.yens.write(graphName :: ANY?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.beta.shortestPath.yens.write.estimate,"gds.beta.shortestPath.yens.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.mutate,"gds.betweenness.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, centralityDistribution :: MAP?, minimumScore :: FLOAT?, maximumScore :: FLOAT?, scoreSum :: FLOAT?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.mutate.estimate,"gds.betweenness.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.stats,"gds.betweenness.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (centralityDistribution :: MAP?, minimumScore :: FLOAT?, maximumScore :: FLOAT?, scoreSum :: FLOAT?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.stats.estimate,"gds.betweenness.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.stream,"gds.betweenness.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.stream.estimate,"gds.betweenness.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,WRITE,gds.betweenness.write,"gds.betweenness.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, writeMillis :: INTEGER?, centralityDistribution :: MAP?, minimumScore :: FLOAT?, maximumScore :: FLOAT?, scoreSum :: FLOAT?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Betweenness centrality measures the relative information flow that passes through a node.,READ,gds.betweenness.write.estimate,"gds.betweenness.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.mutate,"gds.degree.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, centralityDistribution :: MAP?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.mutate.estimate,"gds.degree.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.stats,"gds.degree.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.stats.estimate,"gds.degree.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.stream,"gds.degree.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.stream.estimate,"gds.degree.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,WRITE,gds.degree.write,"gds.degree.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, centralityDistribution :: MAP?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Degree centrality measures the number of incoming and outgoing relationships from a node.,READ,gds.degree.write.estimate,"gds.degree.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.mutate,"gds.fastRP.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.mutate.estimate,"gds.fastRP.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.stats,"gds.fastRP.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.stats.estimate,"gds.fastRP.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.stream,"gds.fastRP.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF NUMBER?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.stream.estimate,"gds.fastRP.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,WRITE,gds.fastRP.write,"gds.fastRP.write(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Random Projection produces node embeddings via the fastrp algorithm,READ,gds.fastRP.write.estimate,"gds.fastRP.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Creates a named graph in the catalog for use by algorithms.,READ,gds.graph.create,"gds.graph.create(graphName :: STRING?, nodeProjection :: ANY?, relationshipProjection :: ANY?, configuration = {} :: MAP?) :: (nodeProjection :: MAP?, relationshipProjection :: MAP?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, createMillis :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Creates a named graph in the catalog for use by algorithms.,READ,gds.graph.create.cypher,"gds.graph.create.cypher(graphName :: STRING?, nodeQuery :: STRING?, relationshipQuery :: STRING?, configuration = {} :: MAP?) :: (nodeQuery :: STRING?, relationshipQuery :: STRING?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, createMillis :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.graph.create.cypher.estimate,"gds.graph.create.cypher.estimate(nodeQuery :: STRING?, relationshipQuery :: STRING?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.graph.create.estimate,"gds.graph.create.estimate(nodeProjection :: ANY?, relationshipProjection :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","",READ,gds.graph.deleteRelationships,"gds.graph.deleteRelationships(graphName :: STRING?, relationshipType :: STRING?) :: (graphName :: STRING?, relationshipType :: STRING?, deletedRelationships :: INTEGER?, deletedProperties :: MAP?)"
"[reader,editor,publisher,architect,admin]",Drops a named graph from the catalog and frees up the resources it occupies.,READ,gds.graph.drop,"gds.graph.drop(graphName :: STRING?, failIfMissing = true :: BOOLEAN?) :: (graphName :: STRING?, database :: STRING?, memoryUsage :: STRING?, sizeInBytes :: INTEGER?, detailSizeInBytes :: MAP?, nodeProjection :: MAP?, relationshipProjection :: MAP?, nodeQuery :: STRING?, relationshipQuery :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, density :: FLOAT?, creationTime :: DATETIME?, modificationTime :: DATETIME?, schema :: MAP?)"
"[reader,editor,publisher,architect,admin]",Checks if a graph exists in the catalog.,READ,gds.graph.exists,"gds.graph.exists(graphName :: STRING?) :: (graphName :: STRING?, exists :: BOOLEAN?)"
"[reader,editor,publisher,architect,admin]",Lists information about named graphs stored in the catalog.,READ,gds.graph.list,"gds.graph.list(graphName = __NO_VALUE :: STRING?) :: (degreeDistribution :: MAP?, graphName :: STRING?, database :: STRING?, memoryUsage :: STRING?, sizeInBytes :: INTEGER?, detailSizeInBytes :: MAP?, nodeProjection :: MAP?, relationshipProjection :: MAP?, nodeQuery :: STRING?, relationshipQuery :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, density :: FLOAT?, creationTime :: DATETIME?, modificationTime :: DATETIME?, schema :: MAP?)"
"[reader,editor,publisher,architect,admin]",Removes node properties from an in-memory graph.,READ,gds.graph.removeNodeProperties,"gds.graph.removeNodeProperties(graphName :: STRING?, nodeProperties :: LIST? OF STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (graphName :: STRING?, nodeProperties :: LIST? OF STRING?, propertiesRemoved :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Streams the given node properties.,READ,gds.graph.streamNodeProperties,"gds.graph.streamNodeProperties(graphName :: STRING?, nodeProperties :: LIST? OF STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, nodeProperty :: STRING?, propertyValue :: ANY?)"
"[reader,editor,publisher,architect,admin]",Streams the given node property.,READ,gds.graph.streamNodeProperty,"gds.graph.streamNodeProperty(graphName :: STRING?, nodeProperties :: STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, propertyValue :: ANY?)"
"[reader,editor,publisher,architect,admin]",Streams the given relationship properties.,READ,gds.graph.streamRelationshipProperties,"gds.graph.streamRelationshipProperties(graphName :: STRING?, relationshipProperties :: LIST? OF STRING?, relationshipTypes = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, relationshipType :: STRING?, relationshipProperty :: STRING?, propertyValue :: NUMBER?)"
"[reader,editor,publisher,architect,admin]",Streams the given relationship property.,READ,gds.graph.streamRelationshipProperty,"gds.graph.streamRelationshipProperty(graphName :: STRING?, relationshipProperties :: STRING?, relationshipTypes = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, relationshipType :: STRING?, propertyValue :: NUMBER?)"
"[editor,publisher,architect,admin]",Writes the given node properties to an online Neo4j database.,WRITE,gds.graph.writeNodeProperties,"gds.graph.writeNodeProperties(graphName :: STRING?, nodeProperties :: LIST? OF STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, graphName :: STRING?, nodeProperties :: LIST? OF STRING?, propertiesWritten :: INTEGER?)"
"[editor,publisher,architect,admin]",Writes the given relationship and an optional relationship property to an online Neo4j database.,WRITE,gds.graph.writeRelationship,"gds.graph.writeRelationship(graphName :: STRING?, relationshipType :: STRING?, relationshipProperty =  :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, graphName :: STRING?, relationshipType :: STRING?, relationshipProperty :: STRING?, relationshipsWritten :: INTEGER?, propertiesWritten :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",The Label Propagation algorithm is a fast algorithm for finding communities in a graph.,READ,gds.labelPropagation.mutate,"gds.labelPropagation.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.labelPropagation.mutate.estimate,"gds.labelPropagation.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.labelPropagation.stats,"gds.labelPropagation.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.labelPropagation.stats.estimate,"gds.labelPropagation.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Label Propagation algorithm is a fast algorithm for finding communities in a graph.,READ,gds.labelPropagation.stream,"gds.labelPropagation.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.labelPropagation.stream.estimate,"gds.labelPropagation.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Label Propagation algorithm is a fast algorithm for finding communities in a graph.,WRITE,gds.labelPropagation.write,"gds.labelPropagation.write(graphName :: ANY?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.labelPropagation.write.estimate,"gds.labelPropagation.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","CALL gds.list - lists all algorithm procedures, their description and signature",DEFAULT,gds.list,"gds.list(name =  :: STRING?) :: (name :: STRING?, description :: STRING?, signature :: STRING?, type :: STRING?)"
"[editor,publisher,architect,admin]","",WRITE,gds.localClusteringCoefficient.mutate,"gds.localClusteringCoefficient.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.localClusteringCoefficient.mutate.estimate,"gds.localClusteringCoefficient.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.localClusteringCoefficient.stats,"gds.localClusteringCoefficient.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.localClusteringCoefficient.stats.estimate,"gds.localClusteringCoefficient.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","",READ,gds.localClusteringCoefficient.stream,"gds.localClusteringCoefficient.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, localClusteringCoefficient :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.localClusteringCoefficient.stream.estimate,"gds.localClusteringCoefficient.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.,WRITE,gds.localClusteringCoefficient.write,"gds.localClusteringCoefficient.write(graphName :: ANY?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.localClusteringCoefficient.write.estimate,"gds.localClusteringCoefficient.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Louvain method for community detection is an algorithm for detecting communities in networks.,WRITE,gds.louvain.mutate,"gds.louvain.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.louvain.mutate.estimate,"gds.louvain.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.louvain.stats,"gds.louvain.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.louvain.stats.estimate,"gds.louvain.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Louvain method for community detection is an algorithm for detecting communities in networks.,READ,gds.louvain.stream,"gds.louvain.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?, intermediateCommunityIds :: LIST? OF INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.louvain.stream.estimate,"gds.louvain.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Louvain method for community detection is an algorithm for detecting communities in networks.,WRITE,gds.louvain.write,"gds.louvain.write(graphName :: ANY?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.louvain.write.estimate,"gds.louvain.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.,READ,gds.nodeSimilarity.mutate,"gds.nodeSimilarity.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.nodeSimilarity.mutate.estimate,"gds.nodeSimilarity.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.nodeSimilarity.stats,"gds.nodeSimilarity.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, similarityPairs :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.nodeSimilarity.stats.estimate,"gds.nodeSimilarity.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.,READ,gds.nodeSimilarity.stream,"gds.nodeSimilarity.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.nodeSimilarity.stream.estimate,"gds.nodeSimilarity.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.,WRITE,gds.nodeSimilarity.write,"gds.nodeSimilarity.write(graphName :: ANY?, configuration = {} :: MAP?) :: (createMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.nodeSimilarity.write.estimate,"gds.nodeSimilarity.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.,READ,gds.pageRank.mutate,"gds.pageRank.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.pageRank.mutate.estimate,"gds.pageRank.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.pageRank.stats,"gds.pageRank.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.pageRank.stats.estimate,"gds.pageRank.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.,READ,gds.pageRank.stream,"gds.pageRank.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.pageRank.stream.estimate,"gds.pageRank.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.,WRITE,gds.pageRank.write,"gds.pageRank.write(graphName :: ANY?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.pageRank.write.estimate,"gds.pageRank.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]","",WRITE,gds.triangleCount.mutate,"gds.triangleCount.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.triangleCount.mutate.estimate,"gds.triangleCount.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.triangleCount.stats,"gds.triangleCount.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.triangleCount.stats.estimate,"gds.triangleCount.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.,READ,gds.triangleCount.stream,"gds.triangleCount.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, triangleCount :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.triangleCount.stream.estimate,"gds.triangleCount.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]",Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.,WRITE,gds.triangleCount.write,"gds.triangleCount.write(graphName :: ANY?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.,READ,gds.triangleCount.write.estimate,"gds.triangleCount.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]","The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.",READ,gds.wcc.mutate,"gds.wcc.mutate(graphName :: ANY?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, componentCount :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.wcc.mutate.estimate,"gds.wcc.mutate.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[reader,editor,publisher,architect,admin]",Executes the algorithm and returns result statistics without writing the result to Neo4j.,READ,gds.wcc.stats,"gds.wcc.stats(graphName :: ANY?, configuration = {} :: MAP?) :: (componentCount :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.wcc.stats.estimate,"gds.wcc.stats.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]","The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.",WRITE,gds.wcc.stream,"gds.wcc.stream(graphName :: ANY?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, componentId :: INTEGER?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.wcc.stream.estimate,"gds.wcc.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"
"[editor,publisher,architect,admin]","The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.",WRITE,gds.wcc.write,"gds.wcc.write(graphName :: ANY?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, componentCount :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :: INTEGER?, createMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)"
"[reader,editor,publisher,architect,admin]",Returns an estimation of the memory consumption for that procedure.,READ,gds.wcc.write.estimate,"gds.wcc.write.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)"