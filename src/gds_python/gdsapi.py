import logging
from gds_python.networkx import adapter
from typing import Any, Callable
import json

class GDSAPI:
    log = logging.getLogger('gds-python')
    reserved_fields = [
        'api', 'driver', 'context', 'generate_callable_neo4j_function', 
        'generate_cypher', 'run', 'fn_description',
        'write_networkx_graph', '__call__', 'input_signature',
        'read_networkx_graph'
    ]

    def __init__(self, api, driver, context='gds'):
        # This API is a list of objects with method names like this:
        # [
        #     { name: "graph.list" }, { name: "foo.bar" }
        # ]
        # Each time you look for an attribute, we see what api matches the prefix
        # (let's say "graph") and return a "sub-api" object
        self.context = context
        self.api = api
        self.driver = driver

    def write_networkx_graph(self, G, label, batch_size=10000, node_properties=[]):
        label, retG = adapter.write_networkx_graph(self.driver, G, label, batch_size)

        orientation = "NATURAL"
        if not G.is_directed(): orientation = "UNDIRECTED"

        nodeProjection = {}
        nodeProjection[str(label)] = { "properties": node_properties }
        relProjection = {}
        relProjection[str(label)] = { "orientation": orientation }
        
        try:
            # Delete the GDS graph if it already exists.
            self.graph.drop(str(label))
        except: pass

        gds_graph = self.graph.create(str(label), nodeProjection, relProjection)
        return label, retG, gds_graph

    def read_networkx_graph(self, label, **kwargs):
        return adapter.read_networkx_graph(self.driver, label, **kwargs)

    def run(self, query, **params):
        with self.driver.session() as session:
            result = session.run(query, **params)
            return [dict(i) for i in result]

    def generate_cypher(self, api, args):
        cypher = "WITH 'This query generated by gds-python v0.01' AS disclaimer\nCALL %s(" % (api['name'])

        l = len(args)
        params = {}
        cps = []
        for i in range(0, l):
            name = "p%d" % i
            params[name] = args[i]
            cps.append(name)
            
        # Add each parameter name in cypher syntax with $p0, $p1, $p2, etc.
        cypher = cypher + ", ".join(list(map(lambda e: "$%s" % e, cps))) + ")\n"

        output_names = map(lambda e: e['name'], api['outputs'])
        all_outputs = ", ".join(list(output_names))

        # Only add a YIELD/RETURN clause if the proc is not VOID return type or empty.
        if len(output_names) > 0:
            cypher = cypher + "YIELD %s" % all_outputs + "\nRETURN %s" % all_outputs
        else:
            cypher = cypher + "RETURN true as finished"

        return cypher, params

    def __getattribute__(self, name: str) -> Callable:
        """Dynamic function fetcher.
        The purpose of this is to allow the user to call any function they like, and dynamically "look up the function" within
        the API specification.  Functions which don't exist return lambdas that always raise Exceptions.  Functions that do
        exist return "callable neo4j functions" that execute the equivalent on the remote server.
        """
        if name in GDSAPI.reserved_fields:
            return object.__getattribute__(self, name)

        here = "%s.%s" % (self.context, name)

        def subdir_api(api_fn):
            new_fn = api_fn.copy()
            # Chop off the leading portion of name, which 
            # navigates one directory down
            new_fn['name'] = api_fn['name'][len(name) + 1:]
            return new_fn

        sub_api = list(map(
            subdir_api,            
            filter(lambda i: i['name'].startswith(name + ".") or i['name'] == name, self.api)))

        GDSAPI.log.debug("MATCHES", list(map(lambda e: e['name'], sub_api)))
        exact_match = None
        exact_matches = list(filter(lambda e: e['name'] == '', sub_api))
        if len(exact_matches) == 1:
            exact_match = exact_matches[0]
            GDSAPI.log.debug("Exact match for %s: %s" % (here, exact_match))

        def failure():
            raise Exception("Method %s does not exist in the GDS API" % name)

        if len(sub_api) == 0:
            return failure

        if exact_match:
            # We have found the single API call the user was after.            
            exact_match['name'] = self.context + ".%s" % name
            return GDSAPI_Concrete_Function(sub_api, self.driver, here, exact_match)

        GDSAPI.log.debug("Recurse: %s with subapi consisting of %d elements" % (here, len(sub_api)))
        return GDSAPI(sub_api, self.driver, here)

class GDSAPI_Concrete_Function(GDSAPI):
    """This class encapsulates a particular GDS function which can also contain a "sub-api".  For example,
       gds.graph.create is a function, but also has sub-api (gds.graph.create.cypher).  This makes it a
       special class of GDSAPI - a concrete function that contains sub-api"""
    def __init__(self, api, driver, context, fn_description):
        GDSAPI.__init__(self, api, driver, context)
        self.fn_description = fn_description
        self.__name__ = fn_description['name']
        self.__doc__ = fn_description['description']
        self.input_signature = { key: self.fn_description[key] for key in ['name', 'description', 'inputs' ]}

    def __call__(self, *args):
        """Given a JSON description of an API function, this function returns another callable function that actually executes the
        relevant cypher on the server and unpacks/delivers results"""       

        required_arguments = list(filter(lambda e: e['required'], self.fn_description['inputs']))
        if len(args) < len(required_arguments) or len(args) > len(self.fn_description['inputs']):
            raise Exception(
                "Invalid input!  You provided %d arguments, when %d are required of %d total. The signature is %s" % (
                    len(args), len(required_arguments), len(self.fn_description['inputs']),
                    json.dumps(self.input_signature, indent=2)))

        if args:
            GDSAPI.log.debug("ARGS %s" % list(map(lambda e: str(e), args)))

        with self.driver.session() as session:
            cypher, params = self.generate_cypher(self.fn_description, args)
            GDSAPI.log.debug("RUNNING CYPHER %s WITH PARAMS %s" % (cypher, params))
            # splat
            results = session.run(cypher, **params)

            # TODO -- for very large result sets this is probably a bad idea, this is just a quick POC
            # This is just to unpack the "neo4j native format" to something friendlier.
            return [dict(i) for i in results]
